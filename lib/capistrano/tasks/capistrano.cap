namespace :load do
  task :defaults do
    set :phoenix_role, -> { :app }
    set :phoenix_mix_env, -> { fetch(:mix_env) }
  end
end

namespace :phoenix do
  def is_application_running?()
    pid = capture(%Q{ps ax -o pid= -o command=|grep "rel/#{fetch(:application)}/.*/[b]eam"|awk '{print $1}'})
    return pid != ""
  end

  desc 'ping'
  task :ping do
    on roles(fetch(:phoenix_role)), in: :sequence do
      within current_path  do
        execute "rel/#{fetch(:application)}/bin/#{fetch(:application)}", "ping"
      end
    end
  end

  desc 'buid assets'
  task :build_assets do
    on roles(fetch(:phoenix_role)), in: :sequence do
      within release_path do
        execute :npm, "install && npm run deploy"
      end
    end
  end

  desc 'build'
  task :build do
    on roles(fetch(:phoenix_role)), in: :sequence do
      within release_path  do
        execute :mix, "deps.get && MIX_ENV=#{fetch(:phoenix_mix_env)} mix compile && MIX_ENV=#{fetch(:phoenix_mix_env)} mix phoenix.digest && MIX_ENV=#{fetch(:phoenix_mix_env)} mix release"
      end
    end
  end

  desc 'restart phoenix app'
  task :restart do
    on roles(fetch(:phoenix_role)), in: :sequence do
      within current_path  do
        if is_application_running?
          execute "rel/#{fetch(:application)}/bin/#{fetch(:application)}", "stop"
          sleep(6)
        end
        execute "rel/#{fetch(:application)}/bin/#{fetch(:application)}", "start"
      end
    end
  end
end

namespace :ecto do
  task :migrate do
    on roles(fetch(:phoenix_role)), in: :sequence do
      within release_path do
        execute :mix, "help > /dev/null && MIX_ENV=#{fetch(:phoenix_mix_env)} mix ecto.migrate"
      end
    end
  end
end

namespace :deploy do
  before "phoenix:build", "phoenix:build_assets"
  after :publishing, "phoenix:build"
  after "phoenix:build", "ecto:migrate"
  after :published, "phoenix:restart"
end
